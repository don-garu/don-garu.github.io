---
title: "Interview Review"
date: 2020-12-16 21:30
categories: Interview
---

## Interview 내용 중

- 라이브러리란?

우선, 라이브러리란? Software 를 만들 때 쓰이는 Class 나 서브루틴들의 모임을 가리키는 말이다.
라이브러리는 보통 다른 프로그램들과 링크될 수 있도록 컴파일된 형태인 목적 코드(Object Code) 형태로 존재하는데, 미리 컴파일 되어있어서 컴파일 시간이 단축될 수 있다.

- 라이브러리의 사용 목적

Library 는 코드 재사용을 위해 사용되는 방법 중 하나이고, 많은 다른 프로그램들에서 사용할 수 있도록 운영체제나 SW 개발 환경제공자들에 의해 제공되는 경우가 많다. 라이브러리 내의 루틴들은 범용적으로 사용 가능하며, 3차원 애니메이션 그래픽과 같이 특별한 용도의 함수로 설계될 수도 있다.

- 라이브러리의 구분

동적 라이브러리 vs. 정적 라이브러리

|.a : 리눅스 / 정적 라이브러리
|.so : 리눅스 / 동적 라이브러리
|.lib : 윈도우 / 정적 라이브러리
|.dll : 윈도우 / 동적 라이브러리

- 동적 라이브러리 (Dynamic Library)

	* DLL 을 구현하고 컴파일하고 나면 Static Library 와는 다르게 Output File 이 2개 생성된다. 하나는 `*.lib` 파일이고, 하나는 `*.dll` 파일이다. 여기서 `*.lib` 파일은 Static Library 의 `*.lib` 파일과는 전혀 다른데, Static Library 의 `*.lib` 파일은 라이브러리 전체 코드를 포함하는 바이너리 파일이고, DLL 의 `*.lib` 파일은 DLL 이 제공하는 함수의 정보(함수명)을 갖는 정보 파일이다.

	* DLL 의 `*.lib` 파일을 이용해 링킹하는 것을 Implicit Linking 이라 하고, 실행 바이너리를 링크 단계에서 실행 바이너리의 `*.obj` 파일들과 DLL 의 `*.lib` 파일을 함께 링크해 이 정보를 토대로 Runtime 에 DLL 의 함수 코드를 참조하게 된다. 즉, 링크 시 `*.lib` 파일을 필요로 하고, 실행 시에는 `*.dll` 파일을 필요로 한다.

	* 반면, Explicit Linking 에서는 `*.lib` 파일을 필요로 하지 않는다. 실행 바이너리 링크 단계에서 DLL 의 함수 정보를 필요로 하지 않기 때문이다. 명시적 링킹에서 사용되는 세 가지 함수는 다음과 같다.
		1. LoadLibrary : 필요한 DLL 을 프로세스의 가상 메모리에 매핑한다.
		2. GetProcAddress : DLL 함수의 포인터를 획득한다.
		3. FreeLibrary : 프로세스 가상 메모리에서 DLL 을 반환한다.
