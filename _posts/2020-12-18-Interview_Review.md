---
title: "Interview Review - Library"
date: 2020-12-16 21:30
categories: Interview
---

## Interview 내용 중

- 라이브러리란?

우선, 라이브러리란? Software 를 만들 때 쓰이는 Class 나 서브루틴들의 모임을 가리키는 말이다.
라이브러리는 보통 다른 프로그램들과 링크될 수 있도록 컴파일된 형태인 목적 코드(Object Code) 형태로 존재하는데, 미리 컴파일 되어있어서 컴파일 시간이 단축될 수 있다.

- 라이브러리의 사용 목적

Library 는 코드 재사용을 위해 사용되는 방법 중 하나이고, 많은 다른 프로그램들에서 사용할 수 있도록 운영체제나 SW 개발 환경제공자들에 의해 제공되는 경우가 많다. 라이브러리 내의 루틴들은 범용적으로 사용 가능하며, 3차원 애니메이션 그래픽과 같이 특별한 용도의 함수로 설계될 수도 있다.

- 라이브러리의 구분

동적 라이브러리 vs. 정적 라이브러리

|.a : 리눅스 / 정적 라이브러리
|.so : 리눅스 / 동적 라이브러리
|.lib : 윈도우 / 정적 라이브러리
|.dll : 윈도우 / 동적 라이브러리

- 동적 라이브러리 (Dynamic Library)

	* DLL 을 구현하고 컴파일하고 나면 Static Library 와는 다르게 Output File 이 2개 생성된다. 하나는 `*.lib` 파일이고, 하나는 `*.dll` 파일이다. 여기서 `*.lib` 파일은 Static Library 의 `*.lib` 파일과는 전혀 다른데, Static Library 의 `*.lib` 파일은 라이브러리 전체 코드를 포함하는 바이너리 파일이고, DLL 의 `*.lib` 파일은 DLL 이 제공하는 함수의 정보(함수명)을 갖는 정보 파일이다.

	* DLL 의 `*.lib` 파일을 이용해 링킹하는 것을 Implicit Linking 이라 하고, 실행 바이너리를 링크 단계에서 실행 바이너리의 `*.obj` 파일들과 DLL 의 `*.lib` 파일을 함께 링크해 이 정보를 토대로 Runtime 에 DLL 의 함수 코드를 참조하게 된다. 즉, 링크 시 `*.lib` 파일을 필요로 하고, 실행 시에는 `*.dll` 파일을 필요로 한다.

	* 반면, Explicit Linking 에서는 `*.lib` 파일을 필요로 하지 않는다. 실행 바이너리 링크 단계에서 DLL 의 함수 정보를 필요로 하지 않기 때문이다. 명시적 링킹에서 사용되는 세 가지 함수는 다음과 같다.
		1. LoadLibrary : 필요한 DLL 을 프로세스의 가상 메모리에 매핑한다.
		2. GetProcAddress : DLL 함수의 포인터를 획득한다.
		3. FreeLibrary : 프로세스 가상 메모리에서 DLL 을 반환한다.
		프로세스는 내부적으로 DLL 의 레퍼런스 카운트를 계산한다. Load 호출 시 DLL 의 레퍼런스 카운터는 1씩 증가하고, Free 호출 시 레퍼런스 카운트가 1씩 감소한다. 레퍼런스 카운트가 0이 되면, 해당 DLL 은 프로세스의 가상 메모리에서 해제된다.

	* 이 때, 주의할 점은 물리 메모리가 아닌 가상 메모리에서의 해제라는 것이다. 레퍼런스 카운트는 각 프로세스 내부의 호출 회수이지, 전체 프로세스 간의 호출 회수가 아니다. 레퍼런스 카운터를 두는 이유는 프로그램 실행 중에 DLL 을 가상 메모리에 할당, 해제할 수 있도록 하기 위함이다.

	* 정리해서 Explicit Linking 의 장점을 설명하자면,
		1. DLL 을 동적으로 로딩/반환 하기 때문에 메모리가 절약된다.
		2. Runtime 중 DLL 을 교체 / 선택이 가능하다.
		3. 암시적 링킹 방식은 프로그램 실행 전에 모든 DLL 이 메모리에 로딩되어 실행까지 걸리는 시간이 길어질 수 있다. 반면, 명시적 링킹은 필요한 순간에 DLL 을 로딩할 수 있어 실행에 걸리는 시간이 짧고, DLL 로딩에 걸리는 시간을 분산시킬 수 있다.

- 동적 라이브러리의 장단점

	* 장점
		1. 메모리 사용 공간을 절약할 수 있다.
		2. DLL 을 쉽게 업그레이드 할 수 있다. (내부 함수가 변경되어도 함수의 호출/반환이 변경되지 않았다면 다시 컴파일하거나 링크할 필요가 없다.)
		3. 서로 다른 프로그래밍 언어로 작성된 프로그램인 경우에도 함수 호출 규칙을 따르기만 하면, 여러 프로그램에서 동일한 DLL 함수를 호출할 수 있다.
		4. 프로그램의 변경 시 변경된 부분의 라이브러리만 재배포하면 되므로 유지보수가 쉽다.

	* 단점
		1. 외부 의존도가 생겨 이식성이 어렵다. ( ? )
		2. 공유 라이브러리를 메모리에 올리려면 찾고 올리는 데 시간이 걸려 성능이 저하된다.

- 정적 라이브러리 (Static Library)

	* 프로그램 빌드 시 라이브러리가 제공하는 코드를 실행 파일에 넣는 방식의 라이브러리를 의미하고, 컴파일의 링크 단계에서 실행 파일에 결합된다.

	* 라이브러리의 동작 코드가 이를 사용하는 실행 바이너리 파일에 포함되기 때문에 별도의 작업 없이, 독립적으로 라이브러리 함수들을 사용할 수 있다.

- 정적 라이브러리의 장단점

	* 장점
		1. 시스템 환경이 변하더라도 애플리케이션에 영향을 주지 않고, 완성된 애플리케이션을 안정적으로 사용할 수 있다.
		2. 컴파일 시 필요한 라이브러리를 프로그램 내에 적재하기 때문에 이식성이 좋다. ( ? )
		3. 런타임 시 외부 참조를 할 필요가 없어 속도에서 장점이 있다.

	* 단점
		1. 같은 코드를 가진 여러 프로그램을 실행할 경우, 코드가 중복이 되어 그만큼 메모리를 낭비하게 된다.
		2. 라이브러리를 변경하게 될 경우, 프로그램 전체를 다시 재배포 해야 한다.

## 결론

정적 라이브러리는 그 라이브러리를 실행 프로그램 내부에 가지게 되고, 동적 라이브러리는 링크 방식의 차이는 있지만 프로그램을 실행할 때 메모리에 적재해서 사용한다.

즉, 정적은 실행 프로그램의 부피(?) 가 커지지만 실행 시에 따로 로드 과정이 없어서 빠르고, 동적은 실행 프로그램의 부피는 작지만 실행 시 따로 로드 과정이 존재해서 느릴 수 있다. 내부에 모든 게 존재하는 시스템인지, 모듈을 사용하는 시스템인지 의 차이로 기억하면 될 듯 하다.

Reference : [동적 라이브러리와 정적 라이브러리][동적-라이브러리와-정적-라이브러리]

[동적-라이브러리와-정적-라이브러리]: https://goodgid.github.io/Static-VS-Dynamic-Libray/
